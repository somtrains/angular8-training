'use strict';

let copyNewer = function () {
  var ref = _asyncToGenerator(function* (src, dest) {
    let opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
    var _opts$cwd = opts.cwd;
    let cwd = _opts$cwd === undefined ? process.cwd() : _opts$cwd;

    src = src.toString();
    dest = dest.toString();
    let files = yield globby(src, opts);
    log(`globbed files: ${ Util.inspect(files) }`);

    // Do copy operations in parallel.
    let operations = [];
    for (let file of files) {
      let realfile = `${ cwd }/${ file }`;
      let destpath = `${ dest }/${ file }`;
      operations.push(copyNewerSingle(realfile, destpath, opts));
    }

    return yield Promise.all(operations);
  });

  return function copyNewer(_x, _x2, _x3) {
    return ref.apply(this, arguments);
  };
}();

// Copies a single file.
// Returns 'dir' if directory, true if successful, false if not.
// Throws Error if not a file and not a directory.


let copyNewerSingle = function () {
  var ref = _asyncToGenerator(function* (srcpath, destpath, opts) {
    var _opts$interval = opts.interval;
    let interval = _opts$interval === undefined ? 1000 : _opts$interval;
    var _opts$verbose = opts.verbose;
    let verbose = _opts$verbose === undefined ? false : _opts$verbose;


    let stat = yield FS.stat(srcpath);
    // Stat and check the filesystem entry type.
    if (stat.isDirectory()) {
      // Directory, ensure destination exists and return.
      let made = yield mkdirp(destpath);
      if (verbose && made) {
        console.log(`${ made } - directory created`);
      }
      return 'dir';
    } else if (!stat.isFile()) {
      // Not a file.
      throw new Error("Not supported.");
    }

    let srcmtime = stat.mtime;
    let destmtime;
    try {
      // Stat destpath and get the mtime.
      destmtime = (yield FS.stat(destpath)).mtime;
    } catch (err) {
      // path does not exist
    }

    if (destmtime !== undefined && srcmtime - destmtime <= interval) {
      // destpath does not exist or mtime is equal, return.
      if (verbose) {
        console.log(`${ srcpath } == ${ destpath }`);
      }
      return false;
    }

    // Ensure parent directory exists.
    yield mkdirp(`${ destpath }/..`);

    // Commence copying.
    let rs = FS.createReadStream(srcpath);
    let ws = FS.createWriteStream(destpath);
    rs.pipe(ws);
    yield waitForStreamEnd(ws);

    // Set mtime to be equal to the source file.
    yield FS.utimes(destpath, new Date(), stat.mtime);

    if (verbose) {
      console.log(`${ srcpath } -> ${ destpath }`);
    }
    return true;
  });

  return function copyNewerSingle(_x5, _x6, _x7) {
    return ref.apply(this, arguments);
  };
}();

let waitForStreamEnd = function () {
  var ref = _asyncToGenerator(function* (stream) {
    yield new Promise(function (resolve, reject) {
      stream.on('error', reject);
      stream.on('finish', resolve);
    });
  });

  return function waitForStreamEnd(_x8) {
    return ref.apply(this, arguments);
  };
}();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

const pify = require('pify');
const globby = require('globby');
const FS_orig = require('graceful-fs');
const FS = pify(FS_orig, { exclude: [/.+Sync$/, /.+Stream$/] });
const fsWriteStreamAtomic = require('fs-write-stream-atomic');
const mkdirp_orig = pify(require('mkdirp'));
const Util = require('util');
const log = Util.debuglog('copy-newer');

function mkdirp(dir) {
  return mkdirp_orig(dir, { fs: FS_orig });
}

module.exports = copyNewer;

if (require.main === module) {
  require('./cli.js');
}